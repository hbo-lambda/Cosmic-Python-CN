# 前言


您可能想知道我们是谁以及为什么写这本书。

在Harry的《[python 测试驱动开发](https://link.zhihu.com/?target=https%3A//www.obeythetestinggoat.com/)》（O'Reilly出版社）结尾，他发现自己问了一堆有关架构的问题，比如，什么是构建应用程序的最佳方式，以便于测试？更具体地说，如何才能让核心业务逻辑被单元测试覆盖，如何才能最大限度地减少所需的集成和端到端测试？他模糊地提到了“六边形架构”、“端口和适配器”和“功能核心、命令式外壳”，但如果他诚实的话，他不得不承认这些并不是他真正理解或实践过的东西

然后他很幸运地遇到了Bob，他对所有这些问题都有答案。

Bob最终成为一名软件架构师，因为他所在团队中没有其他人在从事这方面的工作。事实上他在这方面表现得相当糟糕，但他很幸运地遇到了Ian Cooper，后者教给他编写和思考代码的新方法。


## <font color='red'>管理复杂性，解决业务问题</font>

我们都在MADE.com工作，这是一家在线销售家具的欧洲电子商务公司；在那里，我们应用本书中的技术来构建分布式系统，以模拟现实世界的业务问题。我们的示例域是 Bob 为 MADE 构建的第一个系统，本书试图写下我们在新程序员加入我们团队时要教给他们的所有内容。

MADE.com运营着一个由货运合作伙伴和制造商组成的全球供应链。为了降低成本，我们尝试优化库存到仓库的运送，这样我们才不会有未售出的商品堆积在仓库里。

理想情况下，您要购买的沙发会在您决定购买的当天抵达港口，我们会直接将其运送到您家，无需存放。当货物需要三个月才能通过集装箱船到达时，把握好时机是一项棘手的平衡工作。在运输途中，货物可能会损坏或受潮，风暴会造成意外延误，物流合作伙伴可能会处理不当，文件可能会丢失，客户可能会改变主意并修改订单，等等。

我们通过构建代表现实世界中发生的各种操作的智能软件来解决这些问题，以便我们可以尽可能多地实现业务自动化。


## <font color='red'>为什么选择Python</font>

如果您正在阅读这本书，我们可能不需要说服您Python很棒，因此真正的问题是：“为什么Python社区需要这样一本书？” 答案与Python的流行和成熟度有关：尽管Python可能是全球增长最快的编程语言，且接近绝对流行榜的顶端，但它才刚刚开始解决类似C#和Java世界多年来一直在处理的问题。初创公司逐渐发展成为真正的企业；网络应用程序和脚本自动化逐渐成为（小声说）企业软件。

在Python世界中，我们经常引用Python之禅：“做一件事应该有一种——最好只有一种——显而易见的方法。” 不幸的是，随着项目规模的扩大，最显而易见的处理方式并不总是有助于管理复杂性和需求的不断变化。

本书讨论的技术和模式都不是新的，但它们在Python世界中大多是新的。而且，本书并不是《领域驱动设计》（Eric Evans的著作）或《企业应用程序架构模式》（Martin Fowler的著作）等该领域的经典著作的替代品（这两者均由Addison-Wesley Professional出版）——我们经常引用这些著作并鼓励您去阅读。

但是，书籍中的所有经典代码示例往往都是用Java或C++/#编写的，如果您是Python用户，并且很长时间没有使用过这两种语言（或者实际上从未使用过），那么这些代码列表可能会相当……令人费解。另一本经典著作《重构》（Fowler的著作，Addison-Wesley Professional出版）的最新版本是用JavaScript编写是有原因的。


## <font color='red'>TDD、DDD和事件驱动架构</font>

按照知名度排序，我们知道有三种用于管理复杂性的工具：

1. <em>测试驱动开发</em>（TDD）可帮助我们构建正确的代码，让我们能够重构或添加新功能，而无需担心回归问题。但要充分发挥测试的效果却并非易事：我们如何确保测试运行得尽可能快？我们如何从快速、无依赖的单元测试中获得尽可能多的覆盖范围和反馈，同时将速度较慢且不稳定的端到端测试数量降至最低？
2. <em>领域驱动设计</em>（DDD）要求我们集中精力构建良好的业务领域模型，但如何确保我们的模型不会受到基础设施问题的束缚并且不会变得难以改变？
3. 通过消息集成的松散耦合（微）服务（有时称为 <em>反应式微服务</em>）是管理跨多个应用程序或业务领域的复杂性的成熟解决方案。但如何让它们与 Python 世界中的现有工具（Flask、Django、Celery 等）相适应并不总是显而易见的。

!!! note
    如果您没有使用微服务（或对微服务不感兴趣），也不要气馁。我们讨论的绝大多数模式（包括许多事件驱动架构材料）绝对适用于单体架构。

我们编写这本书的目标是介绍几种经典的架构模式，并展示它们如何支持TDD、DDD和事件驱动服务。我们希望本书能为以Pythonic方式实现这些模式提供参考，并希望人们可以将其作为进一步研究该领域的第一步。


## <font color='red'> 谁应该读这本书</font>

我们假设读者已有以下经历：

- 您已经接触过一些相当复杂的Python应用程序
- 您已经看到了尝试管理这种复杂性所带来的一些痛苦
- 您不一定了解DDD或任何经典的应用程序架构模式

我们围绕示例应用构建架构模式的探索，逐章构建。我们在工作中使用 TDD，因此我们倾向于先展示测试列表，然后再展示实现。如果您不习惯先测试，一开始可能会感觉有点奇怪，但我们希望您能很快习惯先看到代码“被使用”（即从外部），然后再看到代码在内部是如何构建的

我们使用了一些特定的 Python 框架和技术，包括 Flask、SQLAlchemy 和 pytest，以及 Docker 和 Redis。如果您已经熟悉它们，那也没什么坏处，但我们认为这不是必需的。本书的主要目的之一是构建一种架构，其中特定的技术选型只是次要的实现细节。


## <font color='red'>您将学到的内容的简要概述：</font>

本书分为两个部分；以下是我们将要涵盖的主题及其所属章节

**[# 第一部分](./c.Part1.md)**

**领域建模和DDD（第 [1](./d.Domain%20Modeling.md)、[2](./e.Repository%20Pattern.md) 、[7](./j.aggregates%20and%20Consistency%20Boundaries.md) 章）**

在某种程度上，每个人都学到了这样的教训：复杂的业务问题需要以领域模型的形式反映在代码中。但是，为什么在不涉及基础设施问题、Web 框架或其他问题的情况下，这似乎总是如此困难？在第一章中，我们概述了领域建模和 DDD，并展示了如何开始使用没有外部依赖关系的模型和快速单元测试。稍后，我们将回到 DDD 模式，讨论如何选择正确的聚合，以及这种选择与数据完整性问题的关系。

**存储库、服务层和工作单元模式（第 [2](./e.Repository%20Pattern.md)、[4](./g.Flask%20API%20and%20Service%20Layer.md) 、[5](./i.Unit%20of%20Work%20Pattern.md) 章）**

在这三章中，我们介绍了三种密切相关且相互加强的模式，它们支持我们保持模型不受外部依赖的愿望。我们围绕持久存储构建一个抽象层，并构建一个服务层来定义系统的入口点并捕获主要用例。我们展示了这一层如何使我们的系统轻松构建精简入口点，无论是 Flask API 还是 CLI。

**关于测试和抽象的一些想法（第 [3](./f.Coupling%20and%20Abstractions.md)、[5](./h.TDD%20in%20High%20Gear%20and%20Low%20Gear.md) 章）**

在介绍第一个抽象（存储库模式）之后，我们借此机会对如何选择抽象以及它们在选择软件耦合方式方面的作用进行了一般性讨论。在介绍服务层模式之后，我们将讨论如何实现测试金字塔 以及如何在尽可能高的抽象级别编写单元测试。

**[第二部分](./k.Part2.md)**

**事件驱动架构（第 [8](./l.Events%20and%20the%20Message%20Bus.md)-[11](./o.Event-Driven%20Architecture.md) 章）**

我们引入了另外三种相互加强的模式：领域事件、消息总线和处理程序模式。领域事件是一种载体，用于捕捉这样一种思想：与系统的某些交互是其他交互的触发器。我们使用消息总线来允许操作触发事件并调用适当的处理程序。我们继续讨论如何将事件用作微服务架构中服务之间集成的模式。最后，我们区分命令和事件。我们的应用程序现在基本上是一个消息处理系统。

**命令查询责任分离（第 [12](./p.CQRS.md) 章）**

我们给出了一个带有和不带有事件的命令查询责任分离的示例。

**依赖注入（第 [13](./q.Dependency%20Injection.md) 章）**

我们整理了显式和隐式的依赖关系，并实现了一个简单的依赖注入框架。


## <font color='red'>附录</font>

**我该如何从这里到达那里？([结语](./r.Epilogue.md))**

当您展示一个简单的示例时，从头开始实现架构模式总是看起来很容易，但你们中的许多人可能会想知道如何将这些原则应用于现有软件。我们将在结语中提供一些提示和一些进一步阅读的链接。


## <font color='red'> 示例代码和编码</font>

您正在阅读一本书，但当我们说学习代码的最佳方式是编写代码时，您可能会同意我们的观点。我们学到的大部分知识都是通过与人结对、与他们一起编写代码以及边做边学而学到的，我们希望在这本书中尽可能地为您重现这种体验。

因此，我们围绕一个示例项目构建了本书（尽管我们有时会添加其他示例）。随着章节的进展，我们将构建这个项目，就像您与我们配对一样，我们会在每个步骤中解释我们正在做什么以及为什么这样做。

但要真正掌握这些模式，您需要动手修改代码，了解它的原理。您可以在GitHub上找到所有的代码；每章都有自己的分支。您也可以在GitHub上找到[分支](https://github.com/cosmicpython/code/branches/all)列表。

您可以通过以下三种方式跟随本书进行编码：

1. 开始您自己的 repo 并尝试像我们一样构建应用程序，遵循书中列出的示例，偶尔查看我们的 repo 以获取提示。不过，需要提醒的是：如果您已经阅读过 Harry 的上一本书并按照其中的内容编写代码，您会发现这本书需要您自己弄清楚更多内容；您可能需要大量依赖 GitHub 上的可用版本。
2. 尝试逐章将每个模式应用到您自己的（最好是小型/玩具）项目中，看看是否可以使其适合您的用例。这是高风险/高回报（而且需要付出很多努力！）。可能需要做很多工作才能让事情适合您项目的具体情况，但另一方面，您可能会学到最多。
3. 为了减少工作量，我们在每一章中都列出了一个“读者练习”，并为您指出一个 GitHub 位置，您可以在其中下载本章的一些部分完成的代码，其中缺少一些部分需要您自己编写。

特别是如果您打算在自己的项目中应用其中一些模式，那么通过一个简单的示例进行练习是一种安全练习的好方法。

!!! tip
    至少，`git checkout`在阅读每一章时，从我们的代码库中查看代码。能够直接在实际运行的应用程序环境中查看代码将有助于回答很多问题，并使一切变得更加真实。您将在每章开头找到有关如何执行此操作的说明。
